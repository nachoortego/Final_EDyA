5 6 3
0 0
4 5
.....#
.##.##
..#..#
...#.#
.#.#..

. . . . . #
. # # . # #
. # # . . #
. # # # . #
# # # # . R

U D L R
1 4 1 4
1 3 4 2
3 1 1 2
1 3 2 1

Tener lista de
puntos escaneados

/**
 * Acerca al robot lo más posible al objetivo, hasta chocarse obstaculos que se lo impidan.
 * Considera las celdas visitadas como obstaculos, por eso a la funcion move se le pasa un 1. 
 * 'priority' es una variable aleatoria que puede ser 1 o 0, y altera el eje en el que el robot se mueve.
 * De esta manera el robot no tiene peor caso, ya que su movimiento es aleatorio.
 * Devuelve 1 si se realizó al menos un movimiento, 0 si no.
 */
static int camino_corto(Mapa mapa) {
  srand(time(NULL));
  int moved = 0;
  int any_moved = 0; // Variable para rastrear si se realizó algún movimiento

  while (moved) {
    int priority = rand() % 2;
    moved = 0;
    int dx = mapa->objetivo.x - mapa->robot.x; // Distancia x al objetivo
    int dy = mapa->objetivo.y - mapa->robot.y; // Distancia y al objetivo

    // Prioriza movimientos según la distancia al objetivo
    if (priority) { // Si priority es 1, el robot opta por movimientos horizontales
      if (dx > 0 && move(mapa, RIGHT, 1)) {
        moved = 1;
      } else if (dx < 0 && move(mapa, LEFT, 1)) {
        moved = 1;
      } else if (dy > 0 && move(mapa, DOWN, 1)) {
        moved = 1;
      } else if (dy < 0 && move(mapa, UP, 1)) {
        moved = 1;
      }
    } else { // Si priority es 0, opta por movimientos verticales
      if (dy > 0 && move(mapa, DOWN, 1)) {
        moved = 1;
      } else if (dy < 0 && move(mapa, UP, 1)) {
        moved = 1;
      } else if (dx > 0 && move(mapa, RIGHT, 1)) {
        moved = 1;
      } else if (dx < 0 && move(mapa, LEFT, 1)) {
        moved = 1;
      }
    }

    if (moved) {
      any_moved = 1; // Marcar que se realizó al menos un movimiento
    }
  }

  return any_moved;
}